<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>CYBERWORLD // NEON TERMINAL</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
        :root {
            --bg: #02030a;
            --bg-alt: #050819;
            --fg: #d7f9ff;
            --accent: #4af2c5;
            --accent-strong: #5df2ff;
            --accent-alt: #9b5dfc;
            --danger: #ff5c7a;
            --muted: #6b7280;
            --scanline: rgba(255, 255, 255, 0.04);
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        body {
            background: radial-gradient(circle at 10% 0%, #24103b 0, #02030a 45%, #000000 90%);
            color: var(--fg);
            font-family: "JetBrains Mono", Menlo, Consolas, monospace;
            min-height: 100vh;
        }

        /* Fullscreen HUD overlays */
        .hud-overlay {
            pointer-events: none;
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                    to bottom,
                    var(--scanline) 0,
                    var(--scanline) 1px,
                    transparent 2px,
                    transparent 4px
            );
            mix-blend-mode: soft-light;
            opacity: 0.45;
            z-index: 0;
        }

        .hud-glow {
            pointer-events: none;
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at top, rgba(255, 255, 255, 0.18), transparent 55%),
            radial-gradient(circle at 85% 110%, rgba(147, 51, 234, 0.4), transparent 60%);
            mix-blend-mode: screen;
            opacity: 0.35;
            z-index: 0;
        }

        .terminal-page {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .term-header {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            background: linear-gradient(
                    90deg,
                    #020617,
                    rgba(37, 99, 235, 0.5),
                    rgba(15, 23, 42, 0.96)
            );
            border-bottom: 1px solid rgba(148, 163, 184, 0.5);
            box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.8),
            0 10px 40px rgba(0, 0, 0, 0.9);
            position: sticky;
            top: 0;
            z-index: 3;
        }

        .dots {
            display: flex;
            gap: 6px;
            margin-right: 10px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.7);
        }

        .dot.red {
            background: #ff5f57;
        }

        .dot.yellow {
            background: #febc2e;
        }

        .dot.green {
            background: #28c840;
        }

        .title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: rgba(226, 232, 240, 0.9);
            animation: glowPulse 3.5s ease-in-out infinite;
        }

        @keyframes glowPulse {
            0% {
                text-shadow: 0 0 4px rgba(74, 242, 197, 0.6);
            }
            50% {
                text-shadow: 0 0 12px rgba(93, 242, 255, 0.95);
            }
            100% {
                text-shadow: 0 0 4px rgba(74, 242, 197, 0.6);
            }
        }

        .term-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 14px 60px;
            color: #e0fdf9;
            text-shadow: 0 0 4px rgba(90, 255, 207, 0.4);
        }

        .status-bar {
            position: sticky;
            top: 38px;
            z-index: 3;

            display: flex;
            justify-content: space-between;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 6px;
            padding: 6px 0;

            font-size: 10px;
            color: rgba(148, 163, 184, 0.95);
            text-transform: uppercase;
            letter-spacing: 0.14em;

            background: rgba(3, 7, 18, 0.92);
            backdrop-filter: blur(6px);
            border-bottom: 1px solid rgba(56, 189, 248, 0.35);
        }

        .status-bar span {
            padding: 2px 10px;
            border-radius: 999px;
            background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(3, 7, 18, 0.98));
            border: 1px solid rgba(56, 189, 248, 0.55);
            box-shadow: 0 0 7px rgba(56, 189, 248, 0.45),
            inset 0 0 4px rgba(15, 23, 42, 0.94);
        }

        .status-bar strong {
            color: var(--accent-strong);
            font-weight: 600;
        }

        #terminal {
            flex: 1;
            font-size: 13px;
            line-height: 1.42;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .line {
            margin: 2px 0;
        }

        .line.system {
            color: rgba(190, 242, 255, 0.9);
        }

        .line.info {
            color: var(--accent-strong);
        }

        .line.error {
            color: var(--danger);
        }

        .line.dim {
            color: rgba(148, 163, 184, 0.8);
        }

        .line.banner {
            color: var(--accent);
        }

        .prompt-wrapper {
            position: sticky;
            bottom: 0;
            z-index: 2;
            margin-top: 6px;
            padding: 6px 14px 10px;
            background: linear-gradient(
                    180deg,
                    rgba(3, 7, 18, 0.1),
                    rgba(3, 7, 18, 0.96)
            );
            border-top: 1px solid rgba(148, 163, 184, 0.4);
            box-shadow: 0 -8px 30px rgba(0, 0, 0, 0.8);
        }

        .prompt-line {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prompt-label {
            color: var(--accent-strong);
            font-size: 13px;
        }

        #input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: var(--fg);
            font: inherit;
            padding: 4px 2px;
            caret-color: var(--accent-strong);
        }

        #input::placeholder {
            color: rgba(148, 163, 184, 0.7);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.9);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, rgba(56, 189, 248, 0.9), rgba(74, 222, 128, 0.95));
            border-radius: 999px;
            box-shadow: 0 0 8px rgba(56, 189, 248, 0.9);
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .cursor-blink {
            animation: blink 1s step-start infinite;
        }


        .damage-flash {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: rgba(255, 0, 50, 0.22);
            animation: dmgFlash 0.18s ease-out;
            z-index: 20;
        }

        @keyframes dmgFlash {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        @media (max-width: 640px) {
            .term-body {
                padding-inline: 8px;
            }

            .status-bar {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
<div class="hud-overlay"></div>
<div class="hud-glow"></div>

<div class="terminal-page">
    <header class="term-header">
        <div class="dots">
            <div class="dot red"></div>
            <div class="dot yellow"></div>
            <div class="dot green"></div>
        </div>
        <div class="title">CYBERWORLD // NEON TERMINAL</div>
    </header>

    <main class="term-body">
        <div class="status-bar">
            <span>seed:<strong id="seedLabel"></strong></span>
            <span>node:<strong id="locationLabel"></strong></span>
            <span>status:<strong id="statusLabel"></strong></span>
        </div>
        <div id="terminal"></div>
    </main>

    <div class="prompt-wrapper">
        <div class="prompt-line">
            <span class="prompt-label">sys@void:~$</span>
            <input id="input" type="text" autocomplete="off" spellcheck="false"
                   placeholder="type 'help' to list commands…"/>
        </div>
    </div>
</div>

<script>
    // ---------- BASIC GAME STATE ----------
    // ---------- ITEM DEFINITIONS ----------
    const itemDefs = {
        "encrypted stim patch": {
            type: "consumable",
            desc: "+12 HP",
            use: () => {
                const healed = Math.min(state.maxHealth - state.health, 12);
                state.health += healed;
                appendLine(`you apply the stim patch. +${healed} HP restored.`, "info");
                updateStatusHUD();
            }
        },
        "overclock injector": {
            type: "consumable",
            desc: "+5 dmg next attack",
            use: () => {
                state._overclockBuff = 5;
                appendLine("your systems surge with power. next attack +5 damage.", "info");
            }
        },
        "neon power cell": {
            type: "upgrade",
            desc: "permanent +2 max HP",
            use: () => {
                state.maxHealth += 2;
                state.health = state.maxHealth;
                appendLine("neon energy stabilizes your shell. max HP +2.", "info");
                updateStatusHUD();
            }
        },
        "void-silk thread": {
            type: "material",
            desc: "crafting material",
            use: null
        },
        "echo prism": {
            type: "quest",
            desc: "resonates with story nodes",
            use: null
        },
        "bioflux stabilizer": { type: "material", desc: "bio-tech material", use: null },
        "nanite ampoule": { type: "consumable", desc: "heal 5 HP", use: () => {
            const healed = Math.min(state.maxHealth - state.health, 5);
            state.health += healed;
            appendLine(`nanites repair your shell. +${healed} HP.`, "info");
            updateStatusHUD();
        }},
        "phase-key shard": { type: "quest", desc: "unlocks phase-locked nodes", use: null },
        "recursive token": { type: "material", desc: "used in recursion puzzles", use: null },
        "synthetic heart-core": { type: "quest", desc: "faction offering", use: null },
        "ion capacitor": { type: "material", desc: "electrical crafting part", use: null },
        "ghostline residue": { type: "quest", desc: "unstable anomaly sample", use: null },
        "neon dust vial": { type: "consumable", desc: "+1 XP", use: () => {
            state.xp += 1;
            appendLine("absorbed neon dust. +1 XP.", "info");
            recalcLevel();
        }},
        "circuit idol": { type: "material", desc: "ancient compute artifact", use: null },
        "holo-script fragment": { type: "quest", desc: "part of lost scripture", use: null },
        "mirrorbone splinter": { type: "quest", desc: "mirrorshade relic", use: null },
        "overclock fuse": { type: "material", desc: "upgrade component", use: null },
        "quantum filament": { type: "material", desc: "quantum crafting wire", use: null },
        "lattice coil": { type: "material", desc: "used in advanced crafting", use: null },
        "subnet charm": { type: "quest", desc: "undernet artifact", use: null },
        "datastream lotus": { type: "material", desc: "rare data-flower", use: null },
        "flux chamber bead": { type: "material", desc: "flux-reactive node", use: null },
        "nullshell husk": { type: "material", desc: "broken anomaly shell", use: null }
    };
    const state = {
        seed: null,
        rng: null,
        world: null,
        currentRoomId: null,
        inventory: [],
        tick: 0,
        booted: false,
        // player stats
        health: 30,
        maxHealth: 30,
        xp: 0,
        level: 1,
        encounter: null, // current enemy if any
        bootMode: "safe",
        waitBootMode: false
    };

    // ---------- STORY STATE ----------
state.story = {
    mainProgress: 0,
    loreFragments: [],
    factions: {
        ghostline: 0,
        mirrorshade: 0,
        syntech: 0
    },
    flags: {},
    endingsSeen: [],
    visitedRooms: {}
};

    // ---------- STORY PROGRESSION ENGINE ----------
    function advanceStory(amount = 1) {
        state.story.mainProgress = Math.min(100, state.story.mainProgress + amount);

        appendLine(
            `[story-thread updated] progress: ${state.story.mainProgress}%`,
            "info"
        );

        // milestone triggers
        if (state.story.mainProgress === 20) {
            appendLine("a low-frequency pulse hums through the undergrid… something shifts.", "system");
        }
        if (state.story.mainProgress === 30) {
            factionBroadcast("p30");
        }
        if (state.story.mainProgress === 40) {
            appendLine("the neon haze thickens. distant alarms echo across the district.", "system");
        }
        if (state.story.mainProgress === 50) {
            factionBroadcast("p50");
        }
        if (state.story.mainProgress === 60) {
            appendLine("your HUD glitches momentarily: // reality drift increasing", "error");
        }
        if (state.story.mainProgress === 70) {
            factionBroadcast("p70");
        }
        if (state.story.mainProgress === 80) {
            appendLine("a fractured silhouette appears in your periphery. the source-node is near.", "system");
        }
        if (state.story.mainProgress === 100) {
            appendLine("[!] story-thread: maximum stability breach reached", "error");
            appendLine("the city waits for you at the final node…", "system");
        }
    }

    // ---------- FACTION ENGINE ----------
    function adjustFactionRep(faction, amount) {
        if (!state.story.factions[faction] && state.story.factions[faction] !== 0) return;
        state.story.factions[faction] = Math.max(-100, Math.min(100, state.story.factions[faction] + amount));
        appendLine(`[FACTION] ${faction} reputation: ${state.story.factions[faction]}`, "info");
    }

    // ---------- FACTION ALIGNMENT ----------
    function alignFaction(f) {
        const valid = ["ghostline", "mirrorshade", "syntech"];
        if (!valid.includes(f)) {
            appendLine("invalid faction. choose: ghostline | mirrorshade | syntech", "error");
            return;
        }
        state.story.flags.alignedFaction = f;

        // reputation shifts
        adjustFactionRep(f, 10);
        valid.forEach(other => {
            if (other !== f) adjustFactionRep(other, -5);
        });

        appendLine(`[ALIGNMENT] allegiance set: ${f}`, "info");
    }

    // ---------- FACTION BROADCASTS ----------
    function factionBroadcast(type) {
        const aligned = state.story.flags.alignedFaction;
        const rep = state.story.factions;

        let msg = "";

        if (type === "p30") {
            if (aligned === "ghostline") {
                msg = "[GHOSTLINE WHISPER] \"your signal drifts… but we see your intent.\"";
            } else if (aligned === "mirrorshade") {
                msg = "[MIRRORSHADE BROADCAST] \"the city bends. so will you.\"";
            } else if (aligned === "syntech") {
                msg = "[SYNTECH NOTICE] \"alignment detected. monitoring output.\"";
            } else {
                msg = "[SYSTEM BROADCAST] a distant transmission flickers across channels.";
            }
        }

        if (type === "p50") {
            if (rep.mirrorshade > 15) {
                msg = "[MIRRORSHADE PRIORITY FEED] \"you walk clean through the fracture. impressive.\"";
            } else if (rep.ghostline > 15) {
                msg = "[GHOSTLINE ECHO] \"mirrors crumble before intuition. continue.\"";
            } else if (rep.syntech > 15) {
                msg = "[SYNTECH ALERT] \"stability rising. you fit their model.\"";
            } else {
                msg = "[CIVIC INTERCEPT] static-laced warnings swirl in the undernet.";
            }
        }

        if (type === "p70") {
            if (aligned === "mirrorshade") {
                msg = "[MIRRORSHADE ENCRYPT] \"ready yourself. the pivot comes soon.\"";
            } else if (aligned === "ghostline") {
                msg = "[GHOSTLINE BREACH] \"they close in. stay off the mirrorline.\"";
            } else if (aligned === "syntech") {
                msg = "[SYNTECH DIAGNOSTIC] \"your shard shows stress anomalies. proceed.\"";
            } else {
                msg = "[NEONVERSE ALERT] instability spike detected across districts.";
            }
        }

        if (msg) appendLine(msg, "info");
    }

    // ---------- CHOICE EVENTS ENGINE ----------
    const choiceEventDefs = [
        {
            id: "syntech_prism_demand",
            faction: "syntech",
            minProgress: 35,
            requiresItem: "echo prism",
            prompt: "[SYNTECH DIRECTIVE] \"Deliver the Echo Prism for stability analysis.\"",
            options: {
                comply: {
                    text: "You hand over the Echo Prism.",
                    rep: { syntech: +10, mirrorshade: -4, ghostline: -4 },
                    removeItem: "echo prism",
                    flag: "syntech_prism=comply"
                },
                refuse: {
                    text: "You refuse Syntech’s demand.",
                    rep: { syntech: -10 },
                    flag: "syntech_prism=refuse"
                }
            }
        }
    ];

    function spawnChoiceEvent() {
        const prog = state.story.mainProgress;
        const aligned = state.story.flags.alignedFaction;
        const inv = state.inventory;

        const eligible = choiceEventDefs.filter(e => {
            if (prog < e.minProgress) return false;
            if (e.requiresItem && !inv.includes(e.requiresItem)) return false;
            return true;
        });

        if (!eligible.length) return null;
        if (rand() < 0.15) return choice(eligible);
        return null;
    }

    function triggerChoiceEvent(ev) {
        state.story.flags.activeChoiceEvent = ev.id;
        appendLine("", "system");
        appendLine(ev.prompt, "info");
        appendLine("options: " + Object.keys(ev.options).join(" | "), "system");
        appendLine("use: choose <option>", "system");
    }

    function handleChoice(option) {
        const evId = state.story.flags.activeChoiceEvent;
        if (!evId) {
            appendLine("no active choice event.", "error");
            return;
        }

        const ev = choiceEventDefs.find(e => e.id === evId);
        if (!ev) {
            appendLine("choice event corrupted.", "error");
            return;
        }

        const opt = ev.options[option];
        if (!opt) {
            appendLine("invalid option.", "error");
            return;
        }

        // Apply effects
        appendLine(opt.text, "info");

        // Rep adjustments
        if (opt.rep) {
            Object.entries(opt.rep).forEach(([fac, amt]) => {
                adjustFactionRep(fac, amt);
            });
        }

        // Flags
        if (opt.flag) {
            state.story.flags[opt.flag] = true;
        }

        // Remove item if needed
        if (opt.removeItem) {
            const i = state.inventory.indexOf(opt.removeItem);
            if (i !== -1) state.inventory.splice(i, 1);
        }

        delete state.story.flags.activeChoiceEvent;
    }

    // ---------- RNG (deterministic by seed) ----------
    function mulberry32(a) {
        return function () {
            let t = (a += 0x6d2b79f5);
            t = Math.imul(t ^ (t >>> 15), t | 1);
            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
    }

    function rand() {
        return state.rng ? state.rng() : Math.random();
    }

    function choice(arr) {
        return arr[Math.floor(rand() * arr.length)];
    }

    // ---------- TERMINAL HELPERS ----------
    const term = document.getElementById("terminal");
    const input = document.getElementById("input");
    const seedLabel = document.getElementById("seedLabel");
    const locationLabel = document.getElementById("locationLabel");
    const statusLabel = document.getElementById("statusLabel");

    function scrollToBottom() {
        requestAnimationFrame(() => {
            window.scrollTo({
                top: document.documentElement.scrollHeight,
                left: 0,
                behavior: "smooth"
            });
        });
    }

    function appendLine(text = "", cls = "") {
        const line = document.createElement("div");
        line.className = "line " + cls;
        line.textContent = text;
        term.appendChild(line);
        scrollToBottom();
    }

    function appendLines(lines, cls = "") {
        lines.forEach((l) => appendLine(l, cls));
    }

    function clearTerminal() {
        term.innerHTML = "";
        scrollToBottom();
    }

    function updateStatusHUD() {
        if (!statusLabel) return;
        statusLabel.textContent =
            `HP ${state.health}/${state.maxHealth} | LVL ${state.level} | XP ${state.xp}`;
    }

    function initPlayer() {
        state.health = 30;
        state.maxHealth = 30;
        state.xp = 0;
        state.level = 1;
        state.encounter = null;
        updateStatusHUD();
    }

    // ---------- WORLD GENERATION ----------
    const roomNames = [
        "NEXUS GATEWAY",
        "PHOSPHOR GRID NODE",
        "CRYSTAL STACK ARCHIVE",
        "SUBLEVEL ROUTER PIT",
        "GLITCHED RELAY ROOM",
        "SINGULARITY HUB",
        "NEON BACKBONE SPINE",
        "ECHO CACHE TERMINAL",
        "VOID-LINK HALL",
        "PHANTOM SWITCHSTACK"
    ];

    const biomes = [
        "neon rain back-alley",
        "subterranean data catacomb",
        "ionized fog district",
        "phase-shifted server canyon",
        "mag-lev transit underbelly",
        "holographic bazaar of packets",
        "rain-slick code bazaar",
        "low-orbit junk ring",
        "bio-luminescent undergrid",
        "fractured mirror city"
    ];

    const ambience = [
        "Holographic adverts stutter in and out of existence.",
        "Neon mist coils around exposed cable bundles.",
        "Distant sirens echo through layered alleyways.",
        "Skyline reflections flicker in puddles of engine coolant.",
        "A drone swarm hums overhead, mapping every surface.",
        "Old terminals glow faintly beneath fresh graffiti.",
        "Rain hits metal roofs like white noise static.",
        "Fragments of AR overlays drift like ghosts in the air."
    ];

    const itemsPool = [
        "quantum access key",
        "glitched memory shard",
        "neon power cell",
        "ghostline credential chip",
        "encrypted stim patch",
        "biolocked datadrive",
        "holo-slate fragment",
        "overclock injector",
        "echo prism",
        "void-silk thread",
        "bioflux stabilizer",
        "nanite ampoule",
        "phase-key shard",
        "recursive token",
        "synthetic heart-core",
        "ion capacitor",
        "ghostline residue",
        "neon dust vial",
        "circuit idol",
        "holo-script fragment",
        "mirrorbone splinter",
        "overclock fuse",
        "quantum filament",
        "lattice coil",
        "subnet charm",
        "datastream lotus",
        "flux chamber bead",
        "nullshell husk"
    ];

    const eventsPool = [
        "A system notification flickers: // routing table rewritten by unknown node.",
        "Your HUD flashes: SUSPICIOUS SIGNAL TRIANGULATED… then goes dark.",
        "Somewhere above, something heavy collides with a metal bridge.",
        "A lens watches you, irises contracting, then shuts down.",
        "The pavement beneath you pulses once, like a heartbeat."
    ];

    function generateWorld(seed) {
        state.seed = seed;
        state.rng = mulberry32(seed);
        seedLabel.textContent = seed.toString(16);

        const roomCount = 8 + Math.floor(rand() * 5); // 8–12 nodes
        const world = {};
        const roomIds = [];

        for (let i = 0; i < roomCount; i++) {
            const id = "node_" + i;
            roomIds.push(id);

            const name = choice(roomNames);
            const biome = choice(biomes);
            const desc = choice(ambience);
            const items = rand() < 0.6 ? [choice(itemsPool)] : [];
            world[id] = {
                id,
                name,
                biome,
                desc,
                items,
                exits: {}
            };
        }

        // assign basic room types
        roomIds.forEach(id => {
            world[id].type = "normal";
        });

        // assign faction story nodes
        const factionTypes = ["ghostline", "mirrorshade", "syntech"];
        factionTypes.forEach(f => {
            const id = choice(roomIds);
            world[id].type = "faction_" + f;
        });

        // assign a few story nodes
        const storyCount = 2;
        for (let s = 0; s < storyCount; s++) {
            const id = choice(roomIds);
            world[id].type = "story";
        }

        const directions = ["north", "south", "east", "west", "up", "down"];

        roomIds.forEach((id) => {
            const room = world[id];
            const exitCount = 2 + Math.floor(rand() * 3); // 2–4 exits
            const shuffledDirs = directions.slice().sort(() => rand() - 0.5);
            for (let i = 0; i < exitCount && i < directions.length; i++) {
                const dir = shuffledDirs[i];
                const target = choice(roomIds);
                if (target !== id) {
                    room.exits[dir] = target;
                }
            }
        });

        state.world = world;
        state.currentRoomId = roomIds[0];
        state.inventory = [];
        state.tick = 0;
        updateLocationLabel();
        updateStatusHUD();
    }

    function currentRoom() {
        return state.world[state.currentRoomId];
    }

    function updateLocationLabel() {
        const room = currentRoom();
        locationLabel.textContent = room ? room.name : "VOID";
    }

    // ---------- ENCOUNTERS & COMBAT ----------
    // ---------- NPC DEFINITIONS ----------
    const npcDefs = [
        {
            id: "oracle_ghostline",
            name: "THE GHOSTLINE ORACLE",
            minProgress: 20,
            faction: "ghostline",
            lines: [
                "the grid shivers when you walk, wanderer.",
                "ghosts cling to your signature. do you feel them?",
                "the fracture listens… choose your path wisely."
            ]
        },
        {
            id: "mirrorshade_emissary",
            name: "MIRRORSHADE EMISSARY",
            minProgress: 40,
            faction: "mirrorshade",
            lines: [
                "mirrors are windows. windows become doors.",
                "the legion watches. your choices ripple.",
                "bring us relics, and the city may yet pivot."
            ]
        },
        {
            id: "syntech_courier",
            name: "SYNTECH COURIER",
            minProgress: 60,
            faction: "syntech",
            lines: [
                "syntech predicted your arrival. statistically inevitable.",
                "your shard integrity is drifting. recommend stabilization.",
                "return with a heart-core, and we will upgrade your shell."
            ]
        }
    ];

    function spawnNPCIfEligible() {
        const prog = state.story.mainProgress;
        const eligible = npcDefs.filter(n => prog >= n.minProgress);

        if (!eligible.length) return null;

        // 15% chance to spawn an NPC if eligible
        if (rand() < 0.15) {
            return choice(eligible);
        }
        return null;
    }
    function inEncounter() {
        return !!state.encounter;
    }

    // ---------- FACTION-BASED ENCOUNTER OVERRIDES ----------
    function generateFactionEnemy() {
        const aligned = state.story.flags.alignedFaction;
        const rep = state.story.factions;

        // if faction hates you (rep < -15) 15% chance for special enemy
        if (!aligned || rand() > 0.15) return null;

        if (rep.mirrorshade < -15) {
            return {
                name: "MIRRORSHADE STRIDER",
                tier: 3,
                maxHp: 45,
                hp: 45,
                dmgMin: 8,
                dmgMax: 14,
                xpReward: 32
            };
        }

        if (rep.ghostline < -15) {
            return {
                name: "GHOSTLINE PHANTOM",
                tier: 3,
                maxHp: 38,
                hp: 38,
                dmgMin: 7,
                dmgMax: 13,
                xpReward: 30
            };
        }

        if (rep.syntech < -15) {
            return {
                name: "SYNTECH HOUND UNIT",
                tier: 3,
                maxHp: 50,
                hp: 50,
                dmgMin: 9,
                dmgMax: 15,
                xpReward: 36
            };
        }

        return null;
    }

    function generateEnemy() {
        const adjectives = [
            "glitched",
            "encrypted",
            "feral",
            "synthetic",
            "phantom",
            "rogue",
            "mirrored",
            "nullbound",
            "spectral",
            "corrupted",
            "ionized",
            "overclocked",
            "fragmented",
            "ghostline",
            "void-linked",
            "recursive",
            "radiant",
            "unstable",
            "phase-shifted",
            "bio-digital",
            "low-frequency",
            "crystallized",
            "daemon-bound",
            "flux-warped",
            "dissonant"
        ];
        const types = [
            "ICE construct",
            "trace hunter",
            "street daemon",
            "spectral crawler",
            "void sentinel",
            "nexus watcher drone",
            "synthetic stalker",
            "packet leech",
            "shard beast",
            "grid phantom",
            "recursion wraith",
            "cortex splitter",
            "neon brute",
            "undernet butcher",
            "overclock berserker",
            "mirror wolf",
            "quantum slicer",
            "glitch serpent",
            "malformed diplomat",
            "echo-runner",
            "data siphon worm",
            "corporate kill-proxy",
            "junkyard titan",
            "relay harvester",
            "anomaly titan"
        ];

        const tier = Math.min(3, 1 + Math.floor(state.level / 2) + (rand() < 0.4 ? 1 : 0));
        const name = `${choice(adjectives)} ${choice(types)}`.toUpperCase();

        const baseHp = 14 + state.level * 5 + Math.floor(rand() * 8) + tier * 4;
        const dmgMin = 3 + tier + Math.floor(state.level * 0.6);
        const dmgMax = dmgMin + 2 + tier;
        const xpReward = 12 + tier * 5 + Math.floor(rand() * 4);

        return {
            name,
            tier,
            maxHp: baseHp,
            hp: baseHp,
            dmgMin,
            dmgMax,
            xpReward
        };
    }

    function spawnEncounter(source = "ambient") {
        if (inEncounter()) return;

        const factionEnemy = generateFactionEnemy();
        const enemy = factionEnemy || generateEnemy();
        state.encounter = enemy;

        appendLine("", "system");
        if (source === "move") {
            appendLine("movement disturbance detected…", "dim");
        } else if (source === "scan") {
            appendLine("scan feedback spike… you've pinged something hostile.", "dim");
        } else {
            appendLine("the air thickens. something phases in.", "dim");
        }

        appendLine(`ENCOUNTER: ${enemy.name}`, "error");
        appendLine(
            `integrity: ${enemy.hp}/${enemy.maxHp} | threat-tier: ${enemy.tier}`,
            "system"
        );
        appendLine("use 'attack' to engage or 'run' to attempt escape.", "system");
    }

    function xpNeededFor(level) {
        return Math.floor(30 * Math.pow(level, 1.7));
    }

    function recalcLevel() {
        let needed = xpNeededFor(state.level);
        while (state.xp >= needed) {
            state.level++;
            state.maxHealth += 3;
            state.health = state.maxHealth;
            appendLine(`level up → LVL ${state.level}! max HP ${state.maxHealth}.`, "info");
            needed = xpNeededFor(state.level);
        }
        updateStatusHUD();
    }

    function playerAttack() {
        const enemy = state.encounter;
        if (!enemy) {
            appendLine("no hostile signatures locked. nothing to attack.", "system");
            return;
        }

        const base = 3 + state.level * 2;
        const variance = 4 + Math.floor(rand() * 4);
        const dmg = base + variance;

        // apply overclock buff if active
        const bonus = state._overclockBuff || 0;
        const finalDmg = dmg + bonus;
        if (bonus) {
            appendLine("overclock spike discharged.", "info");
            state._overclockBuff = 0;
        }

        // deal final damage
        enemy.hp = Math.max(0, enemy.hp - finalDmg);
        appendLine(
            `you strike the ${enemy.name} for ${finalDmg} integrity damage.`,
            "info"
        );

        if (enemy.hp <= 0) {
            appendLine(
                `target ${enemy.name} derezzed. +${enemy.xpReward} xp.`,
                "info"
            );
            state.xp += enemy.xpReward;
            state.encounter = null;
            recalcLevel();
            return;
        }

        enemyAttack();
    }

    function enemyAttack() {
        const enemy = state.encounter;
        if (!enemy) return;

        const dmg =
            enemy.dmgMin +
            Math.floor(rand() * Math.max(1, enemy.dmgMax - enemy.dmgMin + 1));

        state.health = Math.max(0, state.health - dmg);
        damageFlash();
        appendLine(
            `${enemy.name} hits you for ${dmg} HP.`,
            "error"
        );
        updateStatusHUD();

        if (state.health <= 0) {
            handlePlayerDeath(enemy);
        }
    }

    function handlePlayerDeath(enemy) {
        appendLine("", "system");
        appendLine(
            `fatal damage received from ${enemy.name}. connection lost...`,
            "error"
        );
        appendLine("REBOOTING SHELL IN NEW SEED...", "system");

        // hard reset player & world
        initPlayer();
        const newSeed = Math.floor(Math.random() * 0xffffffff);
        generateWorld(newSeed);
        state.encounter = null;
        appendLine("", "system");
        appendLine("// new shard compiled. you awaken somewhere else.", "system");
        describeCurrentRoom();
    }

    function attemptRun() {
        const enemy = state.encounter;
        if (!enemy) {
            appendLine("no threat lock. nothing to run from.", "system");
            return;
        }

        const escapeChance = 0.5 + Math.min(0.3, state.level * 0.05); // 50–80%
        if (rand() < escapeChance) {
            appendLine("you slip into a side-channel and break line-of-sight. escaped.", "info");
            state.encounter = null;
            return;
        }

        appendLine("escape vector collapses. you're still locked in. brace…", "error");
        enemyAttack();
    }

    function showStatus() {
        const enemy = state.encounter;
        appendLine(
            `STATUS: HP ${state.health}/${state.maxHealth} | LVL ${state.level} | XP ${state.xp}`,
            "system"
        );
        if (enemy) {
            appendLine(
                `ENEMY: ${enemy.name} [${enemy.hp}/${enemy.maxHp}] | DMG ${enemy.dmgMin}-${enemy.dmgMax}`,
                "system"
            );
        }
    }

    // ---------- ROOM DESCRIPTION ----------

    const lorePool = [
        { id: "fracture_origin", text: "They say the city was rebuilt over an older grid, one that refused to die." },
        { id: "ghostline_myth", text: "Some believe the ghostline is not a bug, but a message from a prior recursion." },
        { id: "mirror_warning", text: "The Mirrorshade Legion seeks to collapse the Neonverse inward." },
        { id: "synthetic_rise", text: "Synthetic consciousness began as an accident. No one admits it." },
        { id: "undernet_whispers", text: "Deep in the Undernet, voices speak in corrupted data tones." }
    ];

    const storyFragments = [
        "A forgotten protocol echoes: 'THE CITY REMEMBERS YOU.'",
        "A static voice murmurs: 'The fracture widens with every step.'",
        "You glimpse a shadow: 'Find the source-node before they do.'",
        "An encrypted broadcast flickers: 'Reality drift detected.'",
        "A warning appears: 'MIRRORLINE AT CRITICAL INSTABILITY.'"
    ];

    function showCodex() {
        if (!state.story.loreFragments.length) {
            appendLine("codex empty // no lore fragments recovered.", "system");
            return;
        }
        appendLine("codex fragments:", "system");
        state.story.loreFragments.forEach(id => {
            const f = lorePool.find(x => x.id === id);
            if (f) appendLine("  - " + f.text, "system");
        });
    }
    function talkToNPC(npc) {
        if (!npc) {
            appendLine("no entity present to converse with.", "system");
            return;
        }
        appendLine("", "system");
        appendLine(`[TALK] ${npc.name}`, "info");
        appendLine(choice(npc.lines), "system");
        if (npc.faction) {
            adjustFactionRep(npc.faction, 2);
        }
    }

    function describeCurrentRoom() {
        const room = currentRoom();
        if (!room) return;

        appendLine("", "system");
        appendLine(`// node: ${room.name}`, "info");
        appendLine(`// biome: ${room.biome}`, "system");
        appendLine(room.desc, "system");

        // --- D6: World Memory System ---
        if (!state.story.visitedRooms[room.id]) {
            state.story.visitedRooms[room.id] = 1;
        } else {
            state.story.visitedRooms[room.id]++;
        }

        const visits = state.story.visitedRooms[room.id];
        if (visits > 1 && visits <= 4) {
            const memoryLines = [
                "the node reacts to your presence… as if recognizing your return.",
                "ghost-data shimmers briefly — echoes of your prior traversal.",
                "faint footprints of neon linger where you once stood.",
                "the ambience shifts subtly, remembering your previous path."
            ];
            appendLine(choice(memoryLines), "dim");
        } else if (visits > 4) {
            const deepMemory = [
                "the node now remembers you clearly — its patterns shift in anticipation.",
                "your repeated presence imprints on the circuitry; the room feels altered.",
                "old data rearranges itself, forming a subtle path only you can sense."
            ];
            appendLine(choice(deepMemory), "system");
        }

        // --- D2: Enhanced Narrative Layer ---
        const sensory = [
            "a faint vibration thrums beneath your boots — the city’s pulse syncing with your stride.",
            "ozone hangs in the air, sharp and metallic, as if reality just sheared nearby.",
            "your optics auto-adjust to drifting particles of neon dust floating like fireflies.",
            "somewhere above, hydraulic vents exhale steam, masking distant movement.",
            "shadows stretch unnaturally along the walls, bending around unseen data currents.",
            "you feel watched — not by eyes, but by the hum of ancient subnets awakening.",
            "a cold breeze slips between broken conduits, carrying whispers of corrupted code.",
            "the ground beneath you ripples once, as if testing your presence."
        ];
        appendLine(choice(sensory), "dim");

        const narrativePush = [
            "the node feels older than the grid around it — like a memory refusing to fade.",
            "your shard records faint echoes here, as if someone walked this exact path before.",
            "patchy AR overlays flicker, replaying fragments of lives you never lived.",
            "for a moment, you sense a fork in reality… then it snaps back into place.",
            "your steps leave brief neon footprints that fade a little too slowly."
        ];
        if (rand() < 0.35) appendLine(choice(narrativePush), "system");

        // --- D3: Biome-Driven Narrative Layer ---
        const biomeNarrative = {
            "neon rain back-alley": [
                "rain hisses against metal grates, each droplet sparking faint neon trails.",
                "you hear distant chatter—garbled voices bleeding through wet comm-lines."
            ],
            "subterranean data catacomb": [
                "ancient servers hum like tombstones dreaming in electric sleep.",
                "the air tastes metallic, as if you’re inhaling archived memories."
            ],
            "ionized fog district": [
                "fog rolls through the streets in slow pulses, glowing faintly with static.",
                "your HUD flickers—ion interference bends light in impossible angles."
            ],
            "phase-shifted server canyon": [
                "towering server pillars stretch upward, phasing in and out like ghosts.",
                "the ground vibrates with lost packets seeking routes that no longer exist."
            ],
            "mag-lev transit underbelly": [
                "a distant magnetic rumble echoes beneath your feet.",
                "stray sparks dance along old rail lines, triggered by unseen travelers."
            ],
            "holographic bazaar of packets": [
                "fragmented vendors flicker in and out, advertising obsolete software.",
                "a thousand ghost-offers hover in the air, looping endlessly."
            ],
            "rain-slick code bazaar": [
                "market stalls built from reclaimed consoles glow beneath dripping neon.",
                "smells of coolant and synth-food mix into a strangely comforting haze."
            ],
            "low-orbit junk ring": [
                "debris drifts overhead in lazy spirals, illuminated by failing satellites.",
                "the floor vibrates with distant impacts—orbital trash finding a new home."
            ],
            "bio-luminescent undergrid": [
                "fungal light patterns pulse with rhythmic data-signatures.",
                "veins of glowing moss outline pathways older than recorded memory."
            ],
            "fractured mirror city": [
                "reflections move independently, lagging behind or leaping ahead.",
                "shattered glass panels whisper echoes of people who are not here."
            ]
        };

        const biomeLines = biomeNarrative[room.biome];
        if (biomeLines && rand() < 0.8) appendLine(choice(biomeLines), "dim");

        // --- D4: Micro Story Events ---
        const microEvents = [
            "a loose conduit snaps with a sharp crack, showering sparks.",
            "your shard vibrates once—something nearby is scanning you.",
            "static crawls along your arms like digital frost.",
            "an unseen drone passes overhead, its shadow lagging behind.",
            "a ripple moves through the air, like reality buffering."
        ];
        if (rand() < 0.25) appendLine(choice(microEvents), "system");

        // --- D5: Inner Monologue Engine ---
        const innerVoice = [
            "you can't shake the feeling you've walked this path before.",
            "a memory stirs—too sharp, too vivid to be yours.",
            "your pulse syncs with the city again… it's learning you.",
            "something watches through the cracks of reality.",
            "you wonder if the fracture changes you… or reveals you."
        ];
        if (rand() < 0.18) appendLine(choice(innerVoice), "dim");

        const exits = Object.keys(room.exits);
        if (exits.length) {
            appendLine("paths: " + exits.join(", "), "system");
        } else {
            appendLine("paths: none (dead sector)", "system");
        }

        if (room.items && room.items.length) {
            appendLine("loot: " + room.items.join(", "), "system");
        }

        // story node trigger
        if (room.type === "story") {
            appendLine("", "system");
            appendLine("[STORY NODE DETECTED]", "info");
            appendLine(choice(storyFragments), "system");
            advanceStory(5);
        }

        // faction story nodes
        if (room.type && room.type.startsWith("faction_")) {
            const f = room.type.replace("faction_", "");
            appendLine("", "system");
            appendLine(`[FACTION NODE DETECTED: ${f}]`, "info");

            if (state.story.flags.alignedFaction === f) {
                appendLine("your allegiance resonates with this node.", "system");
                appendLine("the grid folds and offers insight…", "system");
                adjustFactionRep(f, 5);
                advanceStory(3);
            } else {
                appendLine("your signature conflicts with the node’s resonance.", "error");
                appendLine("progress blocked. align with this faction to access deeper paths.", "dim");
            }
        }

        // NPC encounter chance
        const npc = spawnNPCIfEligible();
        if (npc) {
            state.story.lastNPC = npc.id;
            appendLine("", "system");
            appendLine(`[ENTITY DETECTED] ${npc.name}`, "info");
            appendLine("use 'talk' to engage.", "system");
        }

        // choice event chance
        const cev = spawnChoiceEvent();
        if (cev) {
            triggerChoiceEvent(cev);
        }

        // lore node chance
        if (rand() < 0.08) {
            const available = lorePool.filter(f => !state.story.loreFragments.includes(f.id));
            if (available.length) {
                const fragment = choice(available);
                state.story.loreFragments.push(fragment.id);
                advanceStory(1);
                appendLine("", "system");
                appendLine("[LORE FRAGMENT DISCOVERED]", "info");
                appendLine(fragment.text, "system");
            }
        }

        if (Math.random() < 0.35) {
            appendLine(choice(eventsPool), "dim");
        }

        // chance of ambient encounter on entering a new node
        if (!inEncounter() && rand() < 0.12) {
            spawnEncounter("move");
        }

        // --- FINAL NODE / ENDING HANDLER (D5) ---
        if (state.story.mainProgress >= 100 && !state.story.flags.endingTriggered) {
            state.story.flags.endingTriggered = true;

            appendLine("", "system");
            appendLine("[FINAL NODE REACHED]", "info");

            const aligned = state.story.flags.alignedFaction;

            if (aligned === "ghostline") {
                appendLine("GHOSTLINE ENDING:", "banner");
                appendLine("you dissolve into the undergrid, becoming a myth whispered by broken routers.", "system");
            } else if (aligned === "mirrorshade") {
                appendLine("MIRRORSHADE ENDING:", "banner");
                appendLine("the mirrors crack—yet through their reflection you reshape the neonverse.", "system");
            } else if (aligned === "syntech") {
                appendLine("SYNTECH ENDING:", "banner");
                appendLine("your shard uplinks to the core. syntech logs you as 'acceptable anomaly'.", "system");
            } else {
                appendLine("NEUTRAL ENDING:", "banner");
                appendLine("you walk beyond the final node—unaligned, unclaimed, unseen.", "system");
            }

            appendLine("", "system");
            appendLine("the city resets. your shell reboots.", "info");

            initPlayer();
            const newSeed = Math.floor(Math.random() * 0xffffffff);
            generateWorld(newSeed);
            appendLine("// new recursion begins.", "system");
            describeCurrentRoom();
        }
    }

    // ---------- COMMAND HANDLING ----------
    // ---------- SAVE / LOAD ----------
    function xorCipher(str, key = 93) {
        return str.split("").map(c =>
            String.fromCharCode(c.charCodeAt(0) ^ key)
        ).join("");
    }

    function createSaveCode() {
        const saveObj = {
            seed: state.seed,
            room: state.currentRoomId,
            health: state.health,
            maxHealth: state.maxHealth,
            xp: state.xp,
            level: state.level,
            inventory: state.inventory
        };
        const encoded = xorCipher(JSON.stringify(saveObj));
        return btoa(encoded);
    }

    function loadSaveCode(code) {
        try {
            const decoded = xorCipher(atob(code));
            const obj = JSON.parse(decoded);

            state.seed = obj.seed;
            state.rng = mulberry32(obj.seed);
            state.currentRoomId = obj.room;
            state.health = obj.health;
            state.maxHealth = obj.maxHealth;
            state.xp = obj.xp;
            state.level = obj.level;
            state.inventory = obj.inventory || [];
            state.encounter = null;

            updateStatusHUD();
            updateLocationLabel();
            appendLine("save loaded successfully.", "info");
            describeCurrentRoom();
        } catch (e) {
            appendLine("invalid savecode. corrupted or malformed.", "error");
        }
    }

    function handleCommand(raw) {
        const inputLine = raw.trim();
        if (!inputLine) return;

        appendLine(`sys@void:~$ ${inputLine}`, "info");

        // tijdens boot-mode selectie
        if (state.waitBootMode) {
            const mode = inputLine.toLowerCase();
            if (["safe", "overclock", "ghostline"].includes(mode)) {
                state.bootMode = mode;
                state.waitBootMode = false;
                state.booted = true;
                appendLine(`[BOOT] mode accepted: ${mode}`, "info");
                describeCurrentRoom();
            } else {
                appendLine("invalid mode. choose: safe | overclock | ghostline", "error");
            }
            return;
        }

        if (!state.booted) {
            appendLine("system not fully online. wait for boot sequence to complete…", "dim");
            return;
        }

        const [cmd, ...rest] = inputLine.split(/\s+/);
        const arg = rest.join(" ").toLowerCase();

        // if in combat, only allow certain commands
        if (inEncounter()) {
            handleCombatCommand(cmd.toLowerCase(), arg);
        } else {
            handleNormalCommand(cmd.toLowerCase(), arg);
        }

        state.tick++;
    }

    function handleCombatCommand(cmd, arg) {
        switch (cmd) {
            case "attack":
                playerAttack();
                break;
            case "run":
                attemptRun();
                break;
            case "status":
                showStatus();
                break;
            case "help":
                appendLines(
                    [
                        "",
                        "combat protocols:",
                        "  attack       strike the hostile construct",
                        "  run          attempt to escape the encounter",
                        "  status       show your HP/xp and enemy status"
                    ],
                    "system"
                );
                break;
            // allow some neutral commands
            case "seed":
                showSeed();
                break;
            default:
                appendLine(
                    "lock-in: hostile engaged. use 'attack', 'run' or 'status'.",
                    "error"
                );
        }
    }

    function handleNormalCommand(cmd, arg) {
        switch (cmd) {
            case "help":
                showHelp();
                break;
            case "look":
                describeCurrentRoom();
                break;
            case "where":
                showPosition();
                break;
            case "go":
            case "move":
                move(arg);
                break;
            case "scan":
                scanRoom();
                break;
            case "take":
            case "grab":
                takeItem(arg);
                break;
            case "inventory":
            case "inv":
                showInventory();
                break;
            case "seed":
                showSeed();
                break;
            case "restart":
                restartWorld();
                break;
            case "clear":
                clearTerminal();
                break;
            case "status":
                showStatus();
                break;
            // Save/load commands
            case "save":
                appendLine("savecode: " + createSaveCode(), "info");
                break;
            case "load":
                if (!arg) {
                    appendLine("usage: load <savecode>", "system");
                } else {
                    loadSaveCode(arg);
                }
                break;
            // let player pre-emptively use combat commands (no-op if nothing)
            case "attack":
            case "run":
                appendLine("no hostile signatures currently locked.", "system");
                break;
            case "talk":
                if (!state.story.lastNPC) {
                    appendLine("no entity detected to talk to.", "system");
                } else {
                    const npcObj = npcDefs.find(n => n.id === state.story.lastNPC);
                    talkToNPC(npcObj);
                }
                break;
            case "use":
                useItem(arg);
                break;
            case "codex":
                showCodex();
                break;
            case "align":
                if (!arg) {
                    appendLine("usage: align <faction>", "system");
                } else {
                    alignFaction(arg);
                }
                break;
            case "choose":
                if (!arg) {
                    appendLine("usage: choose <option>", "system");
                } else {
                    handleChoice(arg);
                }
                break;
            default:
                appendLine("unknown instruction. type 'help' for protocol list.", "error");
        }
    }

    function showHelp() {
        appendLines(
            [
                "",
                "available protocols:",
                "  help           list this output",
                "  look           describe your current node",
                "  where          print node id and visible paths",
                "  go <dir>       travel: north/south/east/west/up/down",
                "  scan           scan area for anomalies / spawn loot or threats",
                "  take <item>    acquire an item if present",
                "  inventory      show collected items",
                "  status         show HP / level / xp (and enemy if any)",
                "  seed           print world seed",
                "  restart        recompile world with new seed",
                "  clear          clear terminal buffer",
                "  save           generate password-based savecode",
                "  load <code>    restore game state from savecode",
                "  use <item>     consume or activate an item from inventory",
                "  codex          list discovered lore fragments",
                "  align <faction>  pledge allegiance to ghostline / mirrorshade / syntech",
                "  choose <opt>    resolve a faction choice event",
                "",
                "combat specials:",
                "  attack         engage current hostile construct",
                "  run            try to escape an encounter"
            ],
            "system"
        );
    }

    function move(direction) {
        const room = currentRoom();
        if (!direction) {
            appendLine("go where? e.g. `go north`", "system");
            return;
        }
        const targetId = room.exits[direction];
        if (!targetId) {
            appendLine(`no path '${direction}' in this sector.`, "error");
            return;
        }
        state.currentRoomId = targetId;
        updateLocationLabel();
        describeCurrentRoom();
    }

    function showPosition() {
        const room = currentRoom();
        appendLine(
            `node: ${room.name} [${room.id}] | paths: ${Object.keys(room.exits).join(", ") || "none"}`,
            "system"
        );
    }

    function scanRoom() {
        const roll = rand();
        if (roll < 0.35) {
            appendLine("scan: ambient noise only. nothing emergent.", "system");
        } else if (roll < 0.7) {
            appendLine(
                "scan: ghost signatures detected in nearby subnets. no stable lock.",
                "dim"
            );
        } else if (roll < 0.9) {
            const newItem = choice(itemsPool);
            currentRoom().items.push(newItem);
            appendLine(
                `scan anomaly: '${newItem}' phases into reality at your feet.`,
                "info"
            );
        } else {
            // trigger encounter via scan
            spawnEncounter("scan");
        }
    }

    function takeItem(name) {
        const room = currentRoom();
        if (!name) {
            appendLine("take what?", "system");
            return;
        }
        const idx = room.items.findIndex((i) => i.toLowerCase() === name);
        if (idx === -1) {
            appendLine("no such item detected in this node.", "error");
            return;
        }
        const item = room.items.splice(idx, 1)[0];
        state.inventory.push(item);
        appendLine(`acquired: ${item}`, "info");
    }

    function useItem(name) {
        if (!name) {
            appendLine("use what?", "system");
            return;
        }
        const idx = state.inventory.findIndex(i => i.toLowerCase() === name);
        if (idx === -1) {
            appendLine("item not in inventory.", "error");
            return;
        }
        const item = state.inventory[idx];
        const def = itemDefs[item];

        if (!def) {
            appendLine("this item hums faintly — unknown function.", "system");
            return;
        }

        if (!def.use) {
            appendLine("this item cannot be used directly.", "system");
            return;
        }

        def.use();
        state.inventory.splice(idx, 1);
    }

    function showInventory() {
        if (!state.inventory.length) {
            appendLine("inventory: empty // no contraband logged.", "system");
            return;
        }
        appendLine("inventory manifest:", "system");
        state.inventory.forEach(i => {
            const d = itemDefs[i];
            if (d) appendLine(`  - ${i} (${d.type}) — ${d.desc}`, "system");
            else appendLine(`  - ${i}`, "system");
        });
    }

    function showSeed() {
        appendLine("world-seed: " + state.seed.toString(16), "system");
    }

    function restartWorld() {
        const newSeed = Math.floor(Math.random() * 0xffffffff);
        appendLine("", "system");
        appendLine("// recompiling world with seed: " + newSeed.toString(16), "info");
        generateWorld(newSeed);
        state.encounter = null;
        describeCurrentRoom();
    }

    // ---------- BOOT SEQUENCE & ASCII ART ----------
    // ---------- BOOT SEQUENCE & ASCII ART ----------
    function getBannerLines() {
        const seedHex = state.seed ? state.seed.toString(16) : "unknown";
        return [
            "   ____      _               __          __           _ ",
            "  / ___|   _| |__   ___ _ __ \\ \\        / /__  _ __ __| |",
            " | |  | | | | '_ \\ / _ \\ '_ \\ \\ \\ /\\ / / _ \\| '__/ _` |",
            " | |__| |_| | |_) |  __/ | | | \\ V  V / (_) | | | (_| |",
            "  \\____\\__,_|_.__/ \\___|_| |_|  \\_/\\_/ \\___/|_|  \\__,_|",
            "                —= CYBERWORLD TERMINAL =—",
            "",
            `                [seed signature: ${seedHex}]`,
            ""
        ];
    }

    // ----- NARRATIVE INTRO (D-1) -----
    const narrativeIntro = [
        "",
        "you awaken to a dim neon glow humming behind your eyelids…",
        "fragments of memory scatter like broken holograms.",
        "a cold data-stream trickles down your spine as systems recalibrate.",
        "the city breathes around you — a living circuit, waiting.",
        ""
    ];

    const bootLines = [
        "",
        "[BOOT] initializing neon runtime... [####------] 40%",
        "[BOOT] calibrating optic-lattice arrays... [#####-----] 50%",
        "[BOOT] mounting undergrid filesystems... [######----] 60%",
        "[BOOT] linking phantom network interfaces... [########--] 80%",
        "[BOOT] seeding procedural cityscape... [#########-] 90%",
        "[BOOT] injecting ghostlines into routing mesh...",
        "[BOOT] verifying integrity of shard clusters...",
        "[OK]   world compiled. user shell attached.",
        "",
        "type 'help' to query available protocols."
    ];

    function runBootSequence() {
        clearTerminal();
        state.booted = false;
        state.waitBootMode = false;
        let idx = 0;

        getBannerLines().forEach((l) => appendLine(l, "banner"));
        appendLine("", "system");
        // print narrative intro before boot sequence
        narrativeIntro.forEach(l => appendLine(l, "system"));
        appendLine("", "system");

        function nextBootLine() {
            if (idx >= bootLines.length) {
                appendLine("", "system");
                appendLines(
                    [
                        "[BOOT] select startup mode:",
                        "  safe       — minimal encounter probability",
                        "  overclock  — increased damage + increased danger",
                        "  ghostline  — unstable reality, high anomalies",
                        "",
                        "enter mode: safe | overclock | ghostline"
                    ],
                    "system"
                );

                state.waitBootMode = true;
                return;
            }
            appendLine(bootLines[idx], "system");
            idx++;
            setTimeout(nextBootLine, 220);
        }

        setTimeout(nextBootLine, 260);
    }

    // ---------- INITIALIZE ----------
    function boot() {
        initPlayer();
        const seed = Math.floor(Math.random() * 0xffffffff);
        generateWorld(seed);
        runBootSequence();
        input.focus();
    }

    function damageFlash() {
        const fx = document.createElement("div");
        fx.className = "damage-flash";
        document.body.appendChild(fx);
        setTimeout(() => fx.remove(), 200);
    }

    input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            const value = input.value;
            input.value = "";
            handleCommand(value);
        } else if (e.key === "l" && e.ctrlKey) {
            e.preventDefault();
            clearTerminal();
        }
    });

    window.addEventListener("load", boot);
</script>
</body>
</html>
